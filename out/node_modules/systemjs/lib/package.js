System.registerModule("../../../../node_modules/systemjs/lib/package.js", [], function() {
  "use strict";
  var __moduleName = "../../../../node_modules/systemjs/lib/package.js";
  (function() {
    hookConstructor(function(constructor) {
      return function() {
        constructor.call(this);
        this.packages = {};
        this.packageConfigPaths = {};
      };
    });
    function getPackage(name) {
      var curPkg,
          curPkgLen = 0,
          pkgLen;
      for (var p in this.packages) {
        if (name.substr(0, p.length) === p && (name.length === p.length || name[p.length] === '/')) {
          pkgLen = p.split('/').length;
          if (pkgLen > curPkgLen) {
            curPkg = p;
            curPkgLen = pkgLen;
          }
        }
      }
      return curPkg;
    }
    function applyMap(map, name) {
      var bestMatch,
          bestMatchLength = 0;
      for (var p in map) {
        if (name.substr(0, p.length) == p && (name.length == p.length || name[p.length] == '/')) {
          var curMatchLength = p.split('/').length;
          if (curMatchLength <= bestMatchLength)
            continue;
          bestMatch = p;
          bestMatchLength = curMatchLength;
        }
      }
      return bestMatch;
    }
    function getBasePath(pkg) {
      var basePath = pkg.basePath && pkg.basePath != '.' ? pkg.basePath : '';
      if (basePath) {
        if (basePath.substr(0, 2) == './')
          basePath = basePath.substr(2);
        if (basePath[basePath.length - 1] != '/')
          basePath += '/';
      }
      return basePath;
    }
    function toPackagePath(loader, pkgName, pkg, basePath, subPath, sync, isPlugin) {
      var skipExtension = !!(isPlugin || subPath.indexOf('#?') != -1 || subPath.match(interpolationRegEx));
      if (!skipExtension && pkg.modules)
        getMetaMatches(pkg.modules, pkgName, subPath, function(metaPattern, matchMeta, matchDepth) {
          if (matchDepth == 0 || metaPattern.lastIndexOf('*') != metaPattern.length - 1)
            skipExtension = true;
        });
      var normalized = pkgName + '/' + basePath + subPath + (skipExtension ? '' : getDefaultExtension(pkg, subPath));
      return sync ? normalized : booleanConditional.call(loader, normalized, pkgName + '/').then(function(name) {
        return interpolateConditional.call(loader, name, pkgName + '/');
      });
    }
    function getDefaultExtension(pkg, subPath) {
      if (subPath[subPath.length - 1] != '/' && pkg.defaultExtension !== false) {
        var defaultExtension = '.' + (pkg.defaultExtension || 'js');
        if (subPath.substr(subPath.length - defaultExtension.length) != defaultExtension)
          return defaultExtension;
      }
      return '';
    }
    function applyPackageConfig(normalized, pkgName, pkg, sync, isPlugin) {
      var loader = this;
      var basePath = getBasePath(pkg);
      if (pkgName === normalized && pkg.main)
        normalized += '/' + (pkg.main.substr(0, 2) == './' ? pkg.main.substr(2) : pkg.main);
      if (normalized.length == pkgName.length + 1 && normalized[pkgName.length] == '/')
        return normalized;
      if (normalized.length == pkgName.length)
        return normalized + (loader.defaultJSExtensions && normalized.substr(normalized.length - 3, 3) != '.js' ? '.js' : '');
      if (pkg.map) {
        var subPath = '.' + normalized.substr(pkgName.length);
        var map = applyMap(pkg.map, subPath) || !isPlugin && applyMap(pkg.map, (subPath += getDefaultExtension(pkg, subPath.substr(2))));
        var mapped = pkg.map[map];
      }
      function doMap(mapped) {
        if (mapped == '.')
          return pkgName;
        else if (mapped.substr(0, 2) == './')
          return toPackagePath(loader, pkgName, pkg, basePath, mapped.substr(2), sync, isPlugin);
        else
          return (sync ? loader.normalizeSync : loader.normalize).call(loader, mapped);
      }
      if (typeof mapped == 'string')
        return doMap(mapped + subPath.substr(map.length));
      if (sync || !mapped)
        return toPackagePath(loader, pkgName, pkg, basePath, normalized.substr(pkgName.length + 1), sync, isPlugin);
      if (loader.builder)
        return pkgName + '#:' + map.substr(2);
      return loader['import'](pkg.map['@env'] || '@system-env', pkgName).then(function(env) {
        for (var e in mapped) {
          var negate = e[0] == '~';
          var value = readMemberExpression(negate ? e.substr(1) : e, env);
          if (!negate && value || negate && !value)
            return mapped[e] + subPath.substr(map.length);
        }
      }).then(function(mapped) {
        if (!mapped)
          return toPackagePath(loader, pkgName, pkg, basePath, normalized.substr(pkgName.length + 1), sync, isPlugin);
        else
          return doMap(mapped);
      });
    }
    function createPackageNormalize(normalize, sync) {
      return function(name, parentName, isPlugin) {
        isPlugin = isPlugin === true;
        if (parentName)
          var parentPackage = getPackage.call(this, parentName) || this.defaultJSExtensions && parentName.substr(parentName.length - 3, 3) == '.js' && getPackage.call(this, parentName.substr(0, parentName.length - 3));
        if (parentPackage) {
          var parentBasePath = getBasePath(this.packages[parentPackage]);
          if (parentBasePath && parentName.substr(parentPackage.length + 1, parentBasePath.length) == parentBasePath)
            parentName = parentPackage + parentName.substr(parentPackage.length + parentBasePath.length);
          if (name[0] !== '.') {
            var parentMap = this.packages[parentPackage].map;
            if (parentMap) {
              var map = applyMap(parentMap, name);
              if (map) {
                name = parentMap[map] + name.substr(map.length);
                if (name[0] === '.')
                  parentName = parentPackage + '/';
              }
            }
          }
        }
        var defaultJSExtension = this.defaultJSExtensions && name.substr(name.length - 3, 3) != '.js';
        var normalized = normalize.call(this, name, parentName);
        if (defaultJSExtension && normalized.substr(normalized.length - 3, 3) != '.js')
          defaultJSExtension = false;
        if (defaultJSExtension)
          normalized = normalized.substr(0, normalized.length - 3);
        if (parentPackage && name[0] == '.' && normalized == parentPackage + '/')
          normalized = parentPackage;
        var loader = this;
        function packageResolution(normalized, pkgName, pkg) {
          pkgName = pkgName || getPackage.call(loader, normalized);
          var pkg = pkg || pkgName && loader.packages[pkgName];
          if (pkg)
            return applyPackageConfig.call(loader, normalized, pkgName, pkg, sync, isPlugin);
          else
            return normalized + (defaultJSExtension ? '.js' : '');
        }
        if (sync)
          return packageResolution(normalized);
        var pkgName = getPackage.call(this, normalized);
        var pkg = pkgName && this.packages[pkgName];
        if (pkg && pkg.configured)
          return packageResolution(normalized, pkgName, pkg);
        var pkgConfigMatch = pkgConfigPathMatch(loader, normalized);
        if (!pkgConfigMatch.pkgName)
          return packageResolution(normalized, pkgName, pkg);
        return Promise.resolve(getBundleFor(loader, normalized)).then(function(bundle) {
          if (bundle || pkgBundlePromises[pkgConfigMatch.pkgName]) {
            var pkgBundleLoads = pkgBundlePromises[pkgConfigMatch.pkgName] = pkgBundlePromises[pkgConfigMatch.pkgName] || {
              bundles: [],
              promise: Promise.resolve()
            };
            if (bundle && indexOf.call(pkgBundleLoads.bundles, bundle) == -1) {
              pkgBundleLoads.bundles.push(bundle);
              pkgBundleLoads.promise = Promise.all([pkgBundleLoads.promise, loader.load(bundle)]);
            }
            return pkgBundleLoads.promise;
          }
        }).then(function() {
          return packageResolution(normalized, pkgConfigMatch.pkgName);
        }).then(function(curResolution) {
          if (curResolution in loader.defined)
            return curResolution;
          return loadPackageConfigPaths(loader, pkgConfigMatch).then(function() {
            return packageResolution(normalized);
          });
        });
      };
    }
    var pkgBundlePromises = {};
    var packageConfigPathsRegExps = {};
    var pkgConfigPromises = {};
    function pkgConfigPathMatch(loader, normalized) {
      var pkgPath,
          pkgConfigPaths = [];
      for (var i = 0; i < loader.packageConfigPaths.length; i++) {
        var p = loader.packageConfigPaths[i];
        var pPkgLen = Math.max(p.lastIndexOf('*') + 1, p.lastIndexOf('/'));
        var match = normalized.match(packageConfigPathsRegExps[p] || (packageConfigPathsRegExps[p] = new RegExp('^(' + p.substr(0, pPkgLen).replace(/\*/g, '[^\\/]+') + ')(\/|$)')));
        if (match && (!pkgPath || pkgPath == match[1])) {
          pkgPath = match[1];
          pkgConfigPaths.push(pkgPath + p.substr(pPkgLen));
        }
      }
      return {
        pkgName: pkgPath,
        configPaths: pkgConfigPaths
      };
    }
    function loadPackageConfigPaths(loader, pkgConfigMatch) {
      var curPkgConfig = loader.packages[pkgConfigMatch.pkgName];
      if (curPkgConfig && curPkgConfig.configured)
        return Promise.resolve();
      return pkgConfigPromises[pkgConfigMatch.pkgName] || (pkgConfigPromises[pkgConfigMatch.pkgName] = Promise.resolve().then(function() {
        var pkgConfigPromises = [];
        for (var i = 0; i < pkgConfigMatch.configPaths.length; i++)
          (function(pkgConfigPath) {
            pkgConfigPromises.push(loader['fetch']({
              name: pkgConfigPath,
              address: pkgConfigPath,
              metadata: {}
            }).then(function(source) {
              try {
                return JSON.parse(source);
              } catch (e) {
                throw new Error('Invalid JSON in package configuration file ' + pkgConfigPath);
              }
            }).then(function(cfg) {
              if (cfg.systemjs)
                cfg = cfg.systemjs;
              if (cfg.meta) {
                cfg.modules = cfg.meta;
                warn.call(loader, 'Package config file ' + pkgConfigPath + ' is configured with meta, which is deprecated as it has been renamed to modules.');
              }
              for (var p in cfg) {
                if (indexOf.call(packageProperties, p) == -1)
                  delete cfg[p];
              }
              if (cfg.main instanceof Array)
                cfg.main = cfg.main[0];
              if (curPkgConfig)
                extendMeta(cfg, curPkgConfig);
              if (cfg.depCache)
                for (var d in cfg.depCache) {
                  if (d.substr(0, 2) == './')
                    continue;
                  var dNormalized = loader.normalizeSync(d);
                  loader.depCache[dNormalized] = (loader.depCache[dNormalized] || []).concat(cfg.depCache[d]);
                }
              curPkgConfig = loader.packages[pkgConfigMatch.pkgName] = cfg;
            }));
          })(pkgConfigMatch.configPaths[i]);
        return Promise.all(pkgConfigPromises);
      }));
    }
    SystemJSLoader.prototype.normalizeSync = SystemJSLoader.prototype.normalize;
    hook('normalizeSync', function(normalize) {
      return createPackageNormalize(normalize, true);
    });
    hook('normalize', function(normalize) {
      return createPackageNormalize(normalize, false);
    });
    function getMetaMatches(pkgMeta, pkgName, subPath, matchFn) {
      var meta = {};
      var wildcardIndex;
      for (var module in pkgMeta) {
        var dotRel = module.substr(0, 2) == './' ? './' : '';
        if (dotRel)
          module = module.substr(2);
        wildcardIndex = module.indexOf('*');
        if (wildcardIndex === -1)
          continue;
        if (module.substr(0, wildcardIndex) == subPath.substr(0, wildcardIndex) && module.substr(wildcardIndex + 1) == subPath.substr(subPath.length - module.length + wildcardIndex + 1)) {
          matchFn(module, pkgMeta[dotRel + module], module.split('/').length);
        }
      }
      var exactMeta = pkgMeta[subPath] || pkgMeta['./' + subPath];
      if (exactMeta)
        matchFn(exactMeta, exactMeta, 0);
    }
    hook('locate', function(locate) {
      return function(load) {
        var loader = this;
        return Promise.resolve(locate.call(this, load)).then(function(address) {
          var pkgName = getPackage.call(loader, load.name);
          if (pkgName) {
            var pkg = loader.packages[pkgName];
            var basePath = getBasePath(pkg);
            var subPath = load.name.substr(pkgName.length + basePath.length + 1);
            if (pkg.format)
              load.metadata.format = load.metadata.format || pkg.format;
            if (pkg.depCache) {
              for (var d in pkg.depCache) {
                if (d != './' + subPath)
                  continue;
                var deps = pkg.depCache[d];
                for (var i = 0; i < deps.length; i++)
                  loader['import'](deps[i], pkgName + '/');
              }
            }
            var meta = {};
            if (pkg.modules) {
              var bestDepth = 0;
              getMetaMatches(pkg.modules, pkgName, subPath, function(metaPattern, matchMeta, matchDepth) {
                if (matchDepth > bestDepth)
                  bestDepth = matchDepth;
                extendMeta(meta, matchMeta, matchDepth && bestDepth > matchDepth);
              });
              if (meta.alias && meta.alias.substr(0, 2) == './')
                meta.alias = pkgName + meta.alias.substr(1);
              if (meta.loader && meta.loader.substr(0, 2) == './')
                meta.loader = pkgName + meta.loader.substr(1);
              extendMeta(load.metadata, meta);
            }
          }
          return address;
        });
      };
    });
  })();
  return {};
});
System.get("../../../../node_modules/systemjs/lib/package.js" + '');
