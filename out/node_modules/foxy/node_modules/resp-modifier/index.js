System.registerModule("../../../../../node_modules/foxy/node_modules/resp-modifier/index.js", [], function() {
  "use strict";
  var __moduleName = "../../../../../node_modules/foxy/node_modules/resp-modifier/index.js";
  var utils = require("./lib/utils");
  function RespModifier(opts) {
    opts = opts || {};
    opts.blacklist = utils.toArray(opts.blacklist) || [];
    opts.whitelist = utils.toArray(opts.whitelist) || [];
    opts.rules = opts.rules || [];
    opts.ignore = opts.ignore || opts.excludeList || utils.defaultIgnoreTypes;
    opts.regex = (function() {
      var matches = opts.rules.map(function(item) {
        return item.match.source;
      }).join("|");
      return new RegExp(matches);
    })();
    var respMod = this;
    respMod.opts = opts;
    respMod.middleware = respModifierMiddleware;
    respMod.update = function(key, value) {
      if (respMod.opts[key]) {
        respMod.opts[key] = value;
      }
      return respMod;
    };
    function respModifierMiddleware(req, res, next) {
      if (res._respModifier) {
        return next();
      }
      res._respModifier = true;
      var writeHead = res.writeHead;
      var runPatches = true;
      var write = res.write;
      var count = 0;
      var end = res.end;
      res.rulesWritten = [];
      var singlerules = utils.isWhiteListedForSingle(req.url, respMod.opts.rules);
      var withoutSingle = respMod.opts.rules.filter(function(rule) {
        if (rule.paths && rule.paths.length) {
          return false;
        }
        return true;
      });
      if (singlerules.length) {
        modifyResponse(singlerules, true);
      } else {
        if (utils.isWhitelisted(req.url, respMod.opts.whitelist)) {
          modifyResponse(withoutSingle, true);
        } else {
          if (!utils.hasAcceptHeaders(req) || utils.inBlackList(req.url, respMod.opts)) {
            return next();
          } else {
            modifyResponse(withoutSingle);
          }
        }
      }
      next();
      function modifyResponse(rules, force) {
        req.headers["accept-encoding"] = "identity";
        function restore() {
          res.writeHead = writeHead;
          res.write = write;
          res.end = end;
        }
        res.push = function(chunk) {
          res.data = (res.data || "") + chunk;
        };
        res.inject = res.write = function(string, encoding) {
          if (!runPatches) {
            return write.call(res, string, encoding);
          }
          if (string !== undefined) {
            var body = string instanceof Buffer ? string.toString(encoding) : string;
            if (force || (utils.isHtml(body) || utils.isHtml(res.data))) {
              if (utils.exists(body, opts.regex) && !utils.snip(res.data)) {
                res.push(utils.overwriteBody(rules, body, res));
                return true;
              } else {
                res.push(body);
                return true;
              }
            } else {
              restore();
              return write.call(res, string, encoding);
            }
          }
          return true;
        };
        res.writeHead = function() {
          if (!runPatches) {
            return writeHead.apply(res, arguments);
          }
          var headers = arguments[arguments.length - 1];
          if (typeof headers === "object") {
            for (var name in headers) {
              if (/content-length/i.test(name)) {
                delete headers[name];
              }
            }
          }
          if (res.getHeader("content-length")) {
            res.removeHeader("content-length");
          }
          writeHead.apply(res, arguments);
        };
        res.end = function(string, encoding) {
          if (!runPatches) {
            return end.call(res, string, encoding);
          }
          res.inject(string);
          runPatches = false;
          if (utils.isHtml(res.data) && !utils.snip(res.data)) {
            res.data = utils.overwriteBody(rules, res.data, res);
          }
          if (res.data !== undefined && !res._header) {
            res.setHeader("content-length", Buffer.byteLength(res.data, encoding));
          }
          end.call(res, res.data, encoding);
        };
      }
    }
    return respMod;
  }
  module.exports = function(opts) {
    var resp = new RespModifier(opts);
    return resp.middleware;
  };
  module.exports.create = function(opts) {
    var resp = new RespModifier(opts);
    return resp;
  };
  module.exports.utils = utils;
  return {};
});
System.get("../../../../../node_modules/foxy/node_modules/resp-modifier/index.js" + '');
