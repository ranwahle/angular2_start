System.registerModule("../../../../../../node_modules/rx/src/core/internal/isequal.js", [], function() {
  "use strict";
  var __moduleName = "../../../../../../node_modules/rx/src/core/internal/isequal.js";
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      errorClass = '[object Error]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';
  var toString = Object.prototype.toString,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      supportsArgsClass = toString.call(arguments) == argsClass,
      supportNodeClass,
      errorProto = Error.prototype,
      objectProto = Object.prototype,
      stringProto = String.prototype,
      propertyIsEnumerable = objectProto.propertyIsEnumerable;
  try {
    supportNodeClass = !(toString.call(document) == objectClass && !({'toString': 0} + ''));
  } catch (e) {
    supportNodeClass = true;
  }
  var nonEnumProps = {};
  nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
    'constructor': true,
    'toLocaleString': true,
    'toString': true,
    'valueOf': true
  };
  nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
    'constructor': true,
    'toString': true,
    'valueOf': true
  };
  nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
    'constructor': true,
    'toString': true
  };
  nonEnumProps[objectClass] = {'constructor': true};
  var support = {};
  (function() {
    var ctor = function() {
      this.x = 1;
    },
        props = [];
    ctor.prototype = {
      'valueOf': 1,
      'y': 1
    };
    for (var key in new ctor) {
      props.push(key);
    }
    for (key in arguments) {}
    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
    support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
    support.nonEnumArgs = key != 0;
    support.nonEnumShadows = !/valueOf/.test(props);
  }(1));
  var isObject = Rx.internals.isObject = function(value) {
    var type = typeof value;
    return value && (type == 'function' || type == 'object') || false;
  };
  function keysIn(object) {
    var result = [];
    if (!isObject(object)) {
      return result;
    }
    if (support.nonEnumArgs && object.length && isArguments(object)) {
      object = slice.call(object);
    }
    var skipProto = support.enumPrototypes && typeof object == 'function',
        skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
    for (var key in object) {
      if (!(skipProto && key == 'prototype') && !(skipErrorProps && (key == 'message' || key == 'name'))) {
        result.push(key);
      }
    }
    if (support.nonEnumShadows && object !== objectProto) {
      var ctor = object.constructor,
          index = -1,
          length = dontEnumsLength;
      if (object === (ctor && ctor.prototype)) {
        var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),
            nonEnum = nonEnumProps[className];
      }
      while (++index < length) {
        key = dontEnums[index];
        if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
    }
    return result;
  }
  function internalFor(object, callback, keysFunc) {
    var index = -1,
        props = keysFunc(object),
        length = props.length;
    while (++index < length) {
      var key = props[index];
      if (callback(object[key], key, object) === false) {
        break;
      }
    }
    return object;
  }
  function internalForIn(object, callback) {
    return internalFor(object, callback, keysIn);
  }
  function isNode(value) {
    return typeof value.toString != 'function' && typeof(value + '') == 'string';
  }
  var isArguments = function(value) {
    return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;
  };
  if (!supportsArgsClass) {
    isArguments = function(value) {
      return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;
    };
  }
  var isEqual = Rx.internals.isEqual = function(x, y) {
    return deepEquals(x, y, [], []);
  };
  function deepEquals(a, b, stackA, stackB) {
    if (a === b) {
      return a !== 0 || (1 / a == 1 / b);
    }
    var type = typeof a,
        otherType = typeof b;
    if (a === a && (a == null || b == null || (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {
      return false;
    }
    var className = toString.call(a),
        otherClass = toString.call(b);
    if (className == argsClass) {
      className = objectClass;
    }
    if (otherClass == argsClass) {
      otherClass = objectClass;
    }
    if (className != otherClass) {
      return false;
    }
    switch (className) {
      case boolClass:
      case dateClass:
        return +a == +b;
      case numberClass:
        return (a != +a) ? b != +b : (a == 0 ? (1 / a == 1 / b) : a == +b);
      case regexpClass:
      case stringClass:
        return a == String(b);
    }
    var isArr = className == arrayClass;
    if (!isArr) {
      if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
        return false;
      }
      var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
          ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
      if (ctorA != ctorB && !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    var initedStack = !stackA;
    stackA || (stackA = []);
    stackB || (stackB = []);
    var length = stackA.length;
    while (length--) {
      if (stackA[length] == a) {
        return stackB[length] == b;
      }
    }
    var size = 0;
    var result = true;
    stackA.push(a);
    stackB.push(b);
    if (isArr) {
      length = a.length;
      size = b.length;
      result = size == length;
      if (result) {
        while (size--) {
          var index = length,
              value = b[size];
          if (!(result = deepEquals(a[size], value, stackA, stackB))) {
            break;
          }
        }
      }
    } else {
      internalForIn(b, function(value, key, b) {
        if (hasOwnProperty.call(b, key)) {
          size++;
          return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));
        }
      });
      if (result) {
        internalForIn(a, function(value, key, a) {
          if (hasOwnProperty.call(a, key)) {
            return (result = --size > -1);
          }
        });
      }
    }
    stackA.pop();
    stackB.pop();
    return result;
  }
  return {};
});
System.get("../../../../../../node_modules/rx/src/core/internal/isequal.js" + '');
