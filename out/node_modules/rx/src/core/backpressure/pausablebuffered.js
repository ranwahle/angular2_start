System.registerModule("../../../../../../node_modules/rx/src/core/backpressure/pausablebuffered.js", [], function() {
  "use strict";
  var __moduleName = "../../../../../../node_modules/rx/src/core/backpressure/pausablebuffered.js";
  function combineLatestSource(source, subject, resultSelector) {
    return new AnonymousObservable(function(o) {
      var hasValue = [false, false],
          hasValueAll = false,
          isDone = false,
          values = new Array(2),
          err;
      function next(x, i) {
        values[i] = x;
        var res;
        hasValue[i] = true;
        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
          if (err) {
            o.onError(err);
            return;
          }
          try {
            res = resultSelector.apply(null, values);
          } catch (ex) {
            o.onError(ex);
            return;
          }
          o.onNext(res);
        }
        if (isDone && values[1]) {
          o.onCompleted();
        }
      }
      return new CompositeDisposable(source.subscribe(function(x) {
        next(x, 0);
      }, function(e) {
        if (values[1]) {
          o.onError(e);
        } else {
          err = e;
        }
      }, function() {
        isDone = true;
        values[1] && o.onCompleted();
      }), subject.subscribe(function(x) {
        next(x, 1);
      }, function(e) {
        o.onError(e);
      }, function() {
        isDone = true;
        next(true, 1);
      }));
    }, source);
  }
  var PausableBufferedObservable = (function(__super__) {
    inherits(PausableBufferedObservable, __super__);
    function subscribe(o) {
      var q = [],
          previousShouldFire;
      var subscription = combineLatestSource(this.source, this.pauser.distinctUntilChanged().startWith(false), function(data, shouldFire) {
        return {
          data: data,
          shouldFire: shouldFire
        };
      }).subscribe(function(results) {
        if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) {
          previousShouldFire = results.shouldFire;
          if (results.shouldFire) {
            while (q.length > 0) {
              o.onNext(q.shift());
            }
          }
        } else {
          previousShouldFire = results.shouldFire;
          if (results.shouldFire) {
            o.onNext(results.data);
          } else {
            q.push(results.data);
          }
        }
      }, function(err) {
        while (q.length > 0) {
          o.onNext(q.shift());
        }
        o.onError(err);
      }, function() {
        while (q.length > 0) {
          o.onNext(q.shift());
        }
        o.onCompleted();
      });
      return subscription;
    }
    function PausableBufferedObservable(source, pauser) {
      this.source = source;
      this.controller = new Subject();
      if (pauser && pauser.subscribe) {
        this.pauser = this.controller.merge(pauser);
      } else {
        this.pauser = this.controller;
      }
      __super__.call(this, subscribe, source);
    }
    PausableBufferedObservable.prototype.pause = function() {
      this.controller.onNext(false);
    };
    PausableBufferedObservable.prototype.resume = function() {
      this.controller.onNext(true);
    };
    return PausableBufferedObservable;
  }(Observable));
  observableProto.pausableBuffered = function(subject) {
    return new PausableBufferedObservable(this, subject);
  };
  return {};
});
System.get("../../../../../../node_modules/rx/src/core/backpressure/pausablebuffered.js" + '');
