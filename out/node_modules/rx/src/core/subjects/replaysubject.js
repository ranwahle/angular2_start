System.registerModule("../../../../../../node_modules/rx/src/core/subjects/replaysubject.js", [], function() {
  "use strict";
  var __moduleName = "../../../../../../node_modules/rx/src/core/subjects/replaysubject.js";
  var ReplaySubject = Rx.ReplaySubject = (function(__super__) {
    function createRemovableDisposable(subject, observer) {
      return disposableCreate(function() {
        observer.dispose();
        !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
      });
    }
    function subscribe(observer) {
      var so = new ScheduledObserver(this.scheduler, observer),
          subscription = createRemovableDisposable(this, so);
      checkDisposed.call(this);
      this._trim(this.scheduler.now());
      this.observers.push(so);
      for (var i = 0,
          len = this.q.length; i < len; i++) {
        so.onNext(this.q[i].value);
      }
      if (this.hasError) {
        so.onError(this.error);
      } else if (this.isStopped) {
        so.onCompleted();
      }
      so.ensureActive();
      return subscription;
    }
    inherits(ReplaySubject, __super__);
    function ReplaySubject(bufferSize, windowSize, scheduler) {
      this.bufferSize = bufferSize == null ? Number.MAX_VALUE : bufferSize;
      this.windowSize = windowSize == null ? Number.MAX_VALUE : windowSize;
      this.scheduler = scheduler || currentThreadScheduler;
      this.q = [];
      this.observers = [];
      this.isStopped = false;
      this.isDisposed = false;
      this.hasError = false;
      this.error = null;
      __super__.call(this, subscribe);
    }
    addProperties(ReplaySubject.prototype, Observer.prototype, {
      hasObservers: function() {
        return this.observers.length > 0;
      },
      _trim: function(now) {
        while (this.q.length > this.bufferSize) {
          this.q.shift();
        }
        while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) {
          this.q.shift();
        }
      },
      onNext: function(value) {
        checkDisposed.call(this);
        if (this.isStopped) {
          return;
        }
        var now = this.scheduler.now();
        this.q.push({
          interval: now,
          value: value
        });
        this._trim(now);
        var o = this.observers.slice(0);
        for (var i = 0,
            len = o.length; i < len; i++) {
          var observer = o[i];
          observer.onNext(value);
          observer.ensureActive();
        }
      },
      onError: function(error) {
        checkDisposed.call(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        this.error = error;
        this.hasError = true;
        var now = this.scheduler.now();
        this._trim(now);
        var o = this.observers.slice(0);
        for (var i = 0,
            len = o.length; i < len; i++) {
          var observer = o[i];
          observer.onError(error);
          observer.ensureActive();
        }
        this.observers = [];
      },
      onCompleted: function() {
        checkDisposed.call(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        var now = this.scheduler.now();
        this._trim(now);
        var o = this.observers.slice(0);
        for (var i = 0,
            len = o.length; i < len; i++) {
          var observer = o[i];
          observer.onCompleted();
          observer.ensureActive();
        }
        this.observers = [];
      },
      dispose: function() {
        this.isDisposed = true;
        this.observers = null;
      }
    });
    return ReplaySubject;
  }(Observable));
  return {};
});
System.get("../../../../../../node_modules/rx/src/core/subjects/replaysubject.js" + '');
